# -*- coding: utf-8 -*-
"""Mesa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10QMH1r0z9uWEyV5oqOuGNUWdXxAoeq8u
"""

!pip3 -q install mesa

import random
from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
from mesa.datacollection import DataCollector
from mesa.batchrunner import batch_run
import json
import pandas as pd
import numpy as np

class PassengerAgent(Agent):
    def __init__(self, unique_id, model, demographic):
        super().__init__(unique_id, model)
        self.demographic = demographic
        # Define attributes for the passenger agent based on demographics
        if demographic == "Adult":
            self.preferences = {
                "accessibility": np.random.normal(3, 1),
                "leisure_time": random.uniform(1, 5)
            }
            self.willingness_to_pay = {
                "base_price": np.random.normal(20, 4),
                "max_price": np.random.normal(40, 4),
                "price_sensitivity": random.uniform(1, 5)
            }
            self.value_perception = {
                "expected_satisfaction": random.uniform(1, 5),
                "word_of_mouth": random.uniform(1, 5)
            }

        elif demographic == "Senior":
            self.preferences = {
                "accessibility": np.random.normal(3, 1),
                "leisure_time": random.uniform(1, 5)
            }
            self.willingness_to_pay = {
                "base_price": np.random.normal(20, 4),
                "max_price": np.random.normal(40, 4),
                "price_sensitivity": random.uniform(1, 5)
            }
            self.value_perception = {
                "expected_satisfaction": random.uniform(1, 5),
                "word_of_mouth": random.uniform(1, 5)
            }

        elif demographic == "Student":
            self.preferences = {
                "accessibility": np.random.normal(3, 1),
                "leisure_time": random.uniform(1, 5)
            }
            self.willingness_to_pay = {
                "base_price": np.random.normal(20, 4),
                "max_price": np.random.normal(40, 4),
                "price_sensitivity": random.uniform(1, 5)
            }
            self.value_perception = {
                "expected_satisfaction": random.uniform(1, 5),
                "word_of_mouth": random.uniform(1, 5)
            }

        self.ticket_purchased = False

    def step(self):
    # Enhanced decision-making process for purchasing tickets
      if not self.ticket_purchased:
        utility = self.calculate_utility()

        if utility > 2.5 and self.willingness_to_pay["base_price"] <= self.model.ticket_price <= self.willingness_to_pay["max_price"]:                                          # need update this
            # Additional check against minimum satisfaction level
            # if utility >= self.willingness_to_pay["min_satisfaction"]:
            self.ticket_purchased = True




    def determine_weights(self):
    # Weights (each add up to 1)
        adult_1 = [0.4, 0.15, 0.2, 0.1, 0.15] # example
        adult_2 = [0.2, 0.15, 0.2, 0.25, 0.2]
        adult_3 = [0.5, 0.05, 0.25, 0.1, 0.1]
        adult_4 = [0.3, 0.2, 0.1, 0.3, 0.1]
        adults = [adult_1, adult_2, adult_3, adult_4]
        senior_1 = [0.1, 0.25, 0.3, 0.15, 0.2] # example
        senior_2 = [0.2, 0.5, 0.1, 0.1, 0.1]
        senior_3 = [0.25, 0.4, 0.15, 0.15, 0.05]
        senior_4 = [0.2, 0.15, 0.1, 0.3, 0.25]
        seniors = [senior_1, senior_2, senior_3, senior_4]
        student_1 = [0.35, 0.15, 0.1, 0.15, 0.15] # example
        student_2 = [0.3, 0.2, 0.15, 0.25, 0.05]
        student_3 = [0.2, 0.1, 0.25, 0.2, 0.25]
        student_4 = [0.2, 0.25, 0.1, 0.15, 0.3]
        students = [student_1, student_2, student_3, student_4]
        if self.demographic == "Adult":
            return random.choice(adults)  # randomly choose 1  of the 4 weight vectors created for adults
        elif self.demographic == "Senior":
            return random.choice(seniors)  # ''
        elif self.demographic == "Student":
            return random.choice(students)  # ''


    def calculate_utility(self):

        # #  account for competitor prices?
        # price_difference = self.model.competitors_price - self.model.ticket_price

        # if price_difference < 0:
        #     # Your price is lower, increase utility
        #     utility_adjustment = 1 + abs(price_difference / self.model.competitors_price)
        # elif price_difference > 0:
        #     # Your price is higher, reduce utility
        #     utility_adjustment = 1 - abs(price_difference / self.model.ticket_price)
        # else:
        #     utility_adjustment = 1


        features = [
            self.preferences["accessibility"],  # smaller = more important = dont buy
            self.preferences["leisure_time"], # smaller = no time = dont buy
            self.willingness_to_pay["price_sensitivity"], # smaller = more responsive to price changes = dont buy
            self.value_perception["expected_satisfaction"], # smaller = not very happy = dont buy
            self.value_perception["word_of_mouth"] # smaller = harder to influence = dont buy
        ]
        weights = self.determine_weights()
        base_utility = sum(feature * weight for feature, weight in zip(features, weights))

        # Adjust utility based on the adjustment factor
        utility = base_utility
        # * utility_adjustment

        return utility


    #def calculate_utility(self):
    # Consider competitor's pricing in the utility calculation
    #  if self.model.competitors_price < self.model.ticket_price:
    #    # If the competitor's price is lower, reduce the utility
    #      competitor_adjustment = 0.8  # Example: reduce utility by 20%
    #  elif self.model.competitors_price > self.model.ticket_price:
        # If your price is lower, increase the utility
    #      competitor_adjustment = 1.1  # Example: increase utility by 10%
    #  else:
        # If prices are the same, no adjustment
    #      competitor_adjustment = 1.0

     # utility *= competitor_adjustment

     # return utility

class SkyHelixModel(Model):
    def __init__(self, num_passengers, initial_ticket_price,competitors_price, grid_width, grid_height):
        super().__init__()
        self.num_passengers = num_passengers
        self.ticket_price = initial_ticket_price
        self.competitors_price = competitors_price
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.demographic_densities = {
            "Adult": 0.4,
            "Senior": 0.3,
            "Student": 0.1
        }
        self.total_revenue = 0
        self.total_tickets_sold = 0
        self.grid = MultiGrid(self.grid_width, self.grid_height, True)
        self.schedule = RandomActivation(self)
        self.datacollector = DataCollector(
            agent_reporters={"Ticket_Purchased": lambda a: a.ticket_purchased}
        )
        self.create_agents()

    def create_agents(self):
        # Now use self.demographic_densities directly
        total_density = sum(self.demographic_densities.values())
        for demographic, density in self.demographic_densities.items():
            num_agents = int(self.num_passengers * (density / total_density))
            for i in range(num_agents):
                x = self.random.randrange(self.grid.width)
                y = self.random.randrange(self.grid.height)
                agent = PassengerAgent(i, self, demographic)
                self.grid.place_agent(agent, (x, y))
                self.schedule.add(agent)


          # if base price > max price

    def step(self):
        # Adjust the ticket price based on optimization strategy
        self.optimize_ticket_price()

        # Step through the model and collect data
        self.schedule.step()
        self.datacollector.collect(self)

    def optimize_ticket_price(self):
    # Calculate the current demand as the number of agents willing to purchase tickets at the current price
      demand = sum(agent.ticket_purchased for agent in self.schedule.agents)

    # Adjust the ticket price based on demand
      if demand > self.num_passengers / 2:
        self.ticket_price += 1  # Increase price if demand is high
      elif demand < self.num_passengers / 4:
        self.ticket_price -= 1  # Decrease price if demand is low

    # Calculate revenue based on the current ticket price and demand
      self.total_revenue = self.ticket_price * demand  # Corrected to match actual demand

    # Update the total number of tickets sold
      self.total_tickets_sold = demand  # Corrected to reflect actual purchases

    # def optimize_ticket_price(self):
    #     total_demand = 0
    #     for agent in self.schedule.agents:
    #         if agent.demographic == "Family":
    #             total_demand += agent.num_individuals if agent.ticket_purchased else 0
    #         else:
    #             total_demand += 1 if agent.ticket_purchased else 0

    #     # Adjust ticket price based on demand
    #     if total_demand > self.num_passengers / 2:
    #         self.ticket_price += 1  # Increase price if demand is high
    #     elif total_demand < self.num_passengers / 4:
    #         self.ticket_price -= 1  # Decrease price if demand is low

    #     # Calculate revenue based on the current ticket price and total demand
    #     self.total_revenue = self.ticket_price * total_demand

    #     # Update the total number of tickets sold
    #     self.total_tickets_sold = total_demand



    def get_ticket_counts(self):
    # Count the number of tickets purchased
      tickets_purchased = sum(agent.ticket_purchased for agent in self.schedule.agents)
      tickets_not_purchased = self.num_passengers - tickets_purchased

      return tickets_purchased, tickets_not_purchased

    def get_optimized_parameters(self):
    # Include ticket purchase counts directly in the optimized parameters
      tickets_purchased, tickets_not_purchased = self.get_ticket_counts()
      optimized_parameters = {
        "Optimized_Ticket_Price": self.ticket_price,
        "Expected_Passengers": tickets_purchased,  # This now directly reflects tickets purchased
        "Expected_Revenue": self.total_revenue,
        "Tickets_Purchased": tickets_purchased,
        "Tickets_Not_Purchased": tickets_not_purchased
    }

      return optimized_parameters

model = SkyHelixModel(num_passengers=10000, initial_ticket_price=20, competitors_price=50, grid_width=1, grid_height=1)

for i in range(10):
    model.step()

# Access optimized parameters and ticket counts
optimized_parameters = model.get_optimized_parameters()
print("Optimized Ticket Price:", optimized_parameters["Optimized_Ticket_Price"])
print("Expected Passengers:", optimized_parameters["Expected_Passengers"])
print("Expected Revenue:", optimized_parameters["Expected_Revenue"])
print("Tickets Purchased:", optimized_parameters["Tickets_Purchased"])
print("Tickets Not Purchased:", optimized_parameters["Tickets_Not_Purchased"])

# prompt: continue with the plot for my mesa model

import matplotlib.pyplot as plt

# Extract the data from the DataCollector
data = model.datacollector.get_agent_vars_dataframe()

# Create a bar chart to show the number of agents who purchased tickets and those who didn't
plt.bar(['Purchased Tickets', 'Did Not Purchase Tickets'], [optimized_parameters["Tickets_Purchased"], optimized_parameters["Tickets_Not_Purchased"]])

# Set the title and labels for the chart
plt.title('Ticket Purchase Distribution')
plt.xlabel('Ticket Status')
plt.ylabel('Number of Agents')

# Display the chart
plt.show()

parameters = {
    "num_passengers": 10000,
    "initial_ticket_price": range(10, 50, 10),  # Explore prices from $40 to $100
    "competitors_price": 60,  # Fixed competitor price for simplicity
    "grid_width": 1,
    "grid_height": 1
}

# Execute batch run
results = batch_run(
    SkyHelixModel,
    parameters=parameters,
    iterations=5,  # More iterations for averaging
    max_steps=10,
    number_processes=None,
    data_collection_period=-1
)

# Convert results to a DataFrame and analyze or visualize as needed
df = pd.DataFrame(results)

import pandas as pd

# Convert results to a DataFrame
df = pd.DataFrame(results)

# Assuming 'Total_Revenue' was collected as a model_reporter
print(df.head())  # Check the first few rows to ensure it looks correct
print(df.columns)  # This will list all column names in the DataFrame

# Example: Calculate purchase rates at different ticket prices
purchase_rates = df.groupby('initial_ticket_price')['Ticket_Purchased'].mean()

plt.figure(figsize=(10, 6))
plt.plot(purchase_rates.index, purchase_rates.values, marker='o', linestyle='-', color='b')
plt.title('Ticket Purchase Rate vs. Initial Ticket Price')
plt.xlabel('Initial Ticket Price')
plt.ylabel('Purchase Rate')
plt.grid(True)
plt.show()

# Example visualization (assuming 'tickets_sold' is collected)
plt.figure(figsize=(10, 6))
plt.plot(df['initial_ticket_price'], df['num_passengers'], marker='o', linestyle='-')
plt.title('Tickets Sold vs. Ticket Price (Competitor Price at $30)')
plt.xlabel('Our Ticket Price')
plt.ylabel('Tickets Sold')
plt.axvline(x=30, color='r', linestyle='--', label='Competitor Price')
plt.legend()
plt.grid(True)
plt.show()